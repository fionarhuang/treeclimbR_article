
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

During startup - Warning message:
Setting LC_CTYPE failed, using "C" 
> # === tool ========
> .libPaths(c(Sys.getenv('R_LIBS_1'), 
+             Sys.getenv('R_LIBS_2'),
+             Sys.getenv('R_LIBS_3')))
> .libPaths()
[1] "/home/Shared/Rlib/release-3.10-lib" "/usr/local/R/R-3.6.1/library"      
[3] "/home/fiona/tmp/R310_lib"          
> 
> suppressPackageStartupMessages({
+     library(edgeR)
+     library(TreeSummarizedExperiment)
+     library(miLineage)
+ })
> 
> R.Version()
$platform
[1] "x86_64-pc-linux-gnu"

$arch
[1] "x86_64"

$os
[1] "linux-gnu"

$system
[1] "x86_64, linux-gnu"

$status
[1] ""

$major
[1] "3"

$minor
[1] "6.1"

$year
[1] "2019"

$month
[1] "07"

$day
[1] "05"

$`svn rev`
[1] "76782"

$language
[1] "R"

$version.string
[1] "R version 3.6.1 (2019-07-05)"

$nickname
[1] "Action of the Toes"

> # ==== arguments from batch R=====================
> argsList <- (commandArgs(trailingOnly = TRUE))
> argsList
[1] "inRDat='/home/fiona/phd/treeclimbR_article/simulation_microbe/output/RData/DataPrep/US_sp10_sim5_r4_L2.RData'"           
[2] "outRDat='/home/fiona/phd/treeclimbR_article/simulation_microbe/output/RData/Analysis/US_sp10_sim5_r4_L2/miLineage.RData'"
> for (i in seq_along(argsList)) {
+     if(length(argsList[[i]])>1){
+         assign(names(argsList)[i],argsList[[i]])
+     }else{eval(parse(text = argsList[[i]]))}
+ }
> 
> 
> print(inRDat)
[1] "/home/fiona/phd/treeclimbR_article/simulation_microbe/output/RData/DataPrep/US_sp10_sim5_r4_L2.RData"
> 
> ## === load data from data preparation step ===
> load(inRDat)
> limFDR <- 0.05
> # ================= prepare data ====================
> # tree
> Tree <- rowTree(tse)
> mTree <- matTree(tree = Tree)
> rownames(mTree) <- transNode(tree = Tree, node = mTree[, 1], use.alias = TRUE)
> rmTree <- apply(mTree, 1, FUN = function(x){
+     lx <- length(x)
+     lv <- rev(x[!is.na(x)])
+     la <- transNode(tree = Tree, node = lv, use.alias = TRUE,
+                     message = FALSE)
+     fv <- c(la, rep("Unclassified", lx - length(lv)))
+     fv
+ })
> taxTree <- t(rmTree)
> colnames(taxTree) <- paste("Rank", seq_len(ncol(taxTree)), sep = "")
> # count table
> tipDAT <- tse[rowLinks(tse)$isLeaf, ]
> tipCount <- assays(tipDAT, withDimnames = TRUE)
> tipCount <- lapply(tipCount, FUN = function(x) {
+     rownames(x) <- rowLinks(tipDAT)$nodeLab
+     return(x)
+ })
> taxCount <- lapply(tipCount, 
+                    FUN = function(x){
+                        xt <-t(x)
+                        cn <- transNode(tree = rowTree(tse), node = colnames(xt))
+                        colnames(xt) <- transNode(tree = rowTree(tse), 
+                                                  node = cn,
+                                                  use.alias = TRUE)
+                        xt <- xt[, rownames(taxTree)]
+                        return(xt)
+                    })
> 
> # case
> cv <- gsub(pattern = "C", "", colData(tse)$group)
> cv <- factor(cv)
> case <- matrix(as.numeric(cv), ncol = 1,
+                dimnames = list(rownames(taxCount[[1]]), "case"))
> 
> # check OTU order
> all(rownames(taxTree) == colnames(taxCount[[1]]))
[1] TRUE
> # check sample order
> all(rownames(case) == rownames(taxCount[[1]]))
[1] TRUE
> 
> # analysis (resample 100) find nothing
> # one-part analysis
> # system.time({
> # loc1_rs100_0.05.MLA <- lapply(seq_along(taxCount), FUN = function(x){
> #     res <- QCAT(taxCount[[x]], case, 1, taxTree,
> #                 fdr.alpha = limFDR, n.resample = 100)
> #     vres <- res$sig.lineage
> #     cat(x, "out of ", length(taxCount), "has been done", "\n")
> #     return(vres)
> # })
> # })
> # # two - part analysis
> # system.time({
> # loc2_rs100_0.05.MLA <- lapply(seq_along(taxCount), FUN = function(x){
> # 
> #     res <- QCAT_GEE(taxCount[[x]], case, 1, case, 1, taxTree,
> #                     fdr.alpha = limFDR, n.resample = 100)
> #     vres <- res$sig.lineage
> #     ures <- unique(unlist(vres))
> #     cat(x, "out of ", length(taxCount), "has been done", "\n")
> #     return(ures)
> # })
> # })
> 
> # analysis 
> # one-part analysis
> system.time({
+     loc1_0.05.MLA <- lapply(seq_along(taxCount), FUN = function(x){
+     res <- QCAT(taxCount[[x]], case, 1, taxTree,
+                 fdr.alpha = limFDR)
+     vres <- res$sig.lineage
+     ures <- unique(unlist(vres))
+     ures <- transNode(tree = Tree, node = ures)
+     cat(x, "out of ", length(taxCount), "has been done", "\n")
+     return(ures)
+ })
+ })
1 out of  5 has been done 
2 out of  5 has been done 
3 out of  5 has been done 
4 out of  5 has been done 
5 out of  5 has been done 
    user   system  elapsed 
1104.020   10.012  187.608 
> 
> # two - part analysis
> system.time({
+     loc2_0.05.MLA <- lapply(seq_along(taxCount), FUN = function(x){
+     res <- QCAT_GEE(taxCount[[x]], case, 1, case, 1, taxTree,
+                     fdr.alpha = limFDR)
+     vres <- res$sig.lineage
+     ures <- unique(unlist(vres))
+     ures <- transNode(tree = Tree, node = ures)
+     cat(x, "out of ", length(taxCount), "has been done", "\n")
+     return(ures)
+ })
+ })
1 out of  5 has been done 
2 out of  5 has been done 
3 out of  5 has been done 
4 out of  5 has been done 
5 out of  5 has been done 
    user   system  elapsed 
1223.768   12.728  284.108 
> 
> # ------------------0.01 -------------------------------------------
> system.time({
+     loc1_0.01.MLA <- lapply(seq_along(taxCount), FUN = function(x){
+         res <- QCAT(taxCount[[x]], case, 1, taxTree,
+                     fdr.alpha = 0.01)
+         vres <- res$sig.lineage
+         ures <- unique(unlist(vres))
+         ures <- transNode(tree = Tree, node = ures)
+         cat(x, "out of ", length(taxCount), "has been done", "\n")
+         return(ures)
+     })
+ })
1 out of  5 has been done 
2 out of  5 has been done 
3 out of  5 has been done 
4 out of  5 has been done 
5 out of  5 has been done 
    user   system  elapsed 
1147.352   10.824  195.927 
> 
> # two - part analysis
> system.time({
+     loc2_0.01.MLA <- lapply(seq_along(taxCount), FUN = function(x){
+         res <- QCAT_GEE(taxCount[[x]], case, 1, case, 1, taxTree,
+                         fdr.alpha = 0.01)
+         vres <- res$sig.lineage
+         ures <- unique(unlist(vres))
+         ures <- transNode(tree = Tree, node = ures)
+         cat(x, "out of ", length(taxCount), "has been done", "\n")
+         return(ures)
+     })
+ })
1 out of  5 has been done 
2 out of  5 has been done 
3 out of  5 has been done 
4 out of  5 has been done 
5 out of  5 has been done 
    user   system  elapsed 
1268.024   13.688  307.412 
> 
> # ------------------0.1 -------------------------------------------
> system.time({
+     loc1_0.1.MLA <- lapply(seq_along(taxCount), FUN = function(x){
+         res <- QCAT(taxCount[[x]], case, 1, taxTree,
+                     fdr.alpha = 0.1)
+         vres <- res$sig.lineage
+         ures <- unique(unlist(vres))
+         ures <- transNode(tree = Tree, node = ures)
+         cat(x, "out of ", length(taxCount), "has been done", "\n")
+         return(ures)
+     })
+ })
1 out of  5 has been done 
2 out of  5 has been done 
3 out of  5 has been done 
4 out of  5 has been done 
5 out of  5 has been done 
    user   system  elapsed 
1167.184   12.284  216.487 
> 
> # two - part analysis
> system.time({
+     loc2_0.1.MLA <- lapply(seq_along(taxCount), FUN = function(x){
+         res <- QCAT_GEE(taxCount[[x]], case, 1, case, 1, taxTree,
+                         fdr.alpha = 0.1)
+         vres <- res$sig.lineage
+         ures <- unique(unlist(vres))
+         ures <- transNode(tree = Tree, node = ures)
+         cat(x, "out of ", length(taxCount), "has been done", "\n")
+         return(ures)
+     })
+ })
1 out of  5 has been done 
2 out of  5 has been done 
3 out of  5 has been done 
4 out of  5 has been done 
5 out of  5 has been done 
    user   system  elapsed 
1278.032   15.320  313.758 
> 
> 
> 
> ls.mla <- ls()
> # save result
> ind <- grepl(".MLA$", ls.mla)
> obj.mla <- ls.mla[ind]
> save(list=obj.mla,file=outRDat)
> 
> sessionInfo()
R version 3.6.1 (2019-07-05)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 16.04.6 LTS

Matrix products: default
BLAS:   /usr/local/R/R-3.6.1/lib/libRblas.so
LAPACK: /usr/local/R/R-3.6.1/lib/libRlapack.so

locale:
 [1] LC_CTYPE=C                 LC_NUMERIC=C              
 [3] LC_TIME=en_CA.UTF-8        LC_COLLATE=en_CA.UTF-8    
 [5] LC_MONETARY=en_CA.UTF-8    LC_MESSAGES=en_CA.UTF-8   
 [7] LC_PAPER=en_CA.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_CA.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] miLineage_2.1                  geepack_1.3-1                 
 [3] data.table_1.12.6              MASS_7.3-51.4                 
 [5] TreeSummarizedExperiment_1.3.1 SingleCellExperiment_1.8.0    
 [7] SummarizedExperiment_1.16.0    DelayedArray_0.12.0           
 [9] BiocParallel_1.20.0            matrixStats_0.55.0            
[11] Biobase_2.46.0                 GenomicRanges_1.38.0          
[13] GenomeInfoDb_1.22.0            IRanges_2.20.0                
[15] S4Vectors_0.24.0               BiocGenerics_0.32.0           
[17] edgeR_3.28.0                   limma_3.42.0                  

loaded via a namespace (and not attached):
 [1] Rcpp_1.0.2             compiler_3.6.1         pillar_1.4.2          
 [4] XVector_0.26.0         bitops_1.0-6           tools_3.6.1           
 [7] zlibbioc_1.32.0        zeallot_0.1.0          lifecycle_0.1.0       
[10] tibble_2.1.3           nlme_3.1-140           lattice_0.20-38       
[13] pkgconfig_2.0.3        rlang_0.4.1            Matrix_1.2-17         
[16] GenomeInfoDbData_1.2.2 dplyr_0.8.3            vctrs_0.2.0           
[19] generics_0.0.2         locfit_1.5-9.1         grid_3.6.1            
[22] tidyselect_0.2.5       glue_1.3.1             R6_2.4.0              
[25] tidyr_1.0.0            purrr_0.3.3            magrittr_1.5          
[28] backports_1.1.5        assertthat_0.2.1       ape_5.3               
[31] RCurl_1.95-4.12        broom_0.5.2            crayon_1.3.4          
> 
> proc.time()
    user   system  elapsed 
7204.908   76.404 1523.432 
