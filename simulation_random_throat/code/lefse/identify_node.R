# === tool ========
.libPaths(c(Sys.getenv('R_LIBS_1'), 
            Sys.getenv('R_LIBS_2'),
            Sys.getenv('R_LIBS_3')))
.libPaths()

suppressPackageStartupMessages({
    library(stringr)
    library(TreeSummarizedExperiment)
    library(dplyr)
})

R.Version()
# ==== arguments from batch R=====================
argsList <- (commandArgs(trailingOnly = TRUE))
argsList
for (i in seq_along(argsList)) {
    if(length(argsList[[i]])>1){
        assign(names(argsList)[i],argsList[[i]])
    }else{eval(parse(text = argsList[[i]]))}
}

## ===============================================

print(inDat)
print(outDat)




# folder path: store .res files generated by lefse
print(resPath)

# load tree
load(inDat)

# a function to remove ancestors
rm_ancestor <- function(node, tree) {
    if (!length(node)) {
        node
    } else {
        loc <- node
        # each row is a path connecting a leaf to the root
        mat <- matTree(tree = tree)
        # which paths are detected nodes on?
        lat <- lapply(loc, FUN = function(x){
            which(mat == x, arr.ind = TRUE)
        })
        lat1 <- do.call(rbind.data.frame, lat)
        lat1 <- lat1 %>% 
            group_by(row) %>% 
            arrange(col) %>%
            as.matrix()
        
        # nodes in paths where exist only one detected nodes
        lat2 <- lat1[!duplicated(lat1[, 1]), ]
        k2 <- unique(mat[lat2])
        # nodes in paths where exist more one detected nodes
        # (node that is closest to the leaf level not included)
        lat3 <- lat1[duplicated(lat1[, 1]), ]
        k3 <- unique(mat[lat3])
        
        # remove nodes 
        kk <- intersect(k2, k3)
        setdiff(loc, kk)  
    }
}
# a function to extract nodes identified by lefse
loc_fun <- function(x, tree, reso = "high") {
    res <- read.delim(file.path(resPath, x), header=FALSE)
    colnames(res) <- c("taxon", "log.max.pct", "direction", "lda", "p.value")
    
    suppressWarnings({
        res_f <- res %>%
            mutate(p.value = as.numeric(as.character(p.value))) %>%
            filter(!is.na(p.value))
        
    })
    
    nodeS <- gsub(pattern = ".*\\.", replacement = "", x = res_f$taxon)
    nodeS <- transNode(tree = tree, node = nodeS)
    
    if (reso == "high") {
        rm_ancestor(node = nodeS, tree = tree)
    } else {
        nodeS
    }
    
}

# all .res files
files <- list.files(resPath)

# each file stores results of a simulation at a specified FDR
df <- data.frame(file = files) %>%
    mutate(fdr = str_match(file, "@(.*?)\\.res")[,2],
           fdr = as.numeric(as.character(fdr)),
           main = gsub(pattern = "_rep.*", "", file),
           rep = str_match(file, "_rep(.*?)@")[,2]) 

# extract nodes from each file
df_scene <- split(df, df$main)    
out_lefse_high <- lapply(df_scene, FUN = function(x) {
    xx <- split(x, x$fdr)
    xy <- lapply(xx, FUN = function(y){
        lapply(y$file, FUN = function(z){
            loc_fun(z, tree = tree, reso = "high")
        })
    })
    xy
})

out_lefse_low <- lapply(df_scene, FUN = function(x) {
    xx <- split(x, x$fdr)
    xy <- lapply(xx, FUN = function(y){
        lapply(y$file, FUN = function(z){
            loc_fun(z, tree = tree, reso = "low")
        })
    })
    xy
})
save(out_lefse_low, out_lefse_high, file = outDat)


